redo 重做，重新执行一遍之前的操作
undo 撤销，也就是取消之前的操作

insert (比如一个插入操作，新分配了一些数据块。
后来事务失败，插入操作全部回滚，新分配的一些数据块还是存在的---高水位)

数据库宕机---重启 数据库后----需要实例恢复
oracle会读取redo log 实现事物前滚再现这个插入操作---发现这个事物并没有提交---这个时候需要回滚
（利用的是刚才前滚产生的回滚段undo）

一种情况：已经有一部分数据写到了磁盘上(缓冲区缓存已满)
	DBWR 将任何有修改的块写至磁盘之前，LGWR必须先刷新输出与这些块相关的redo信息。
	DBWR 触发 DBWR 写redo到磁盘的操作，----然后是dbwr 将数据缓存区的数据写到磁盘上的数据文件里面
(也就是任何一条修改记录持久化到数据文件的时候，
必须先把它对应的redo条目持久化到磁盘文件，以保证这个过程的可逆性)

一种情况是没有写到磁盘上---这样根本不需要上面的实例恢复过程
---SGA里面也没有相关记录(sga已经被清理了)

update 
数据库宕机----重启数据库后---需要实例恢复
	跟insert 过程差不多，就是update 产生的回滚段 更多；需要保存一些“前“映像(改前值)
	启动时，oracle会去读取重做日志文件，会发现有一些redo文件对应的修改记录还没有持久化到数据文件。
	然后发现这些redo文件是一个事务里面的，于是得回滚这个事务。步骤如下：

     a. 根据redo文件，进行数据前滚，会在内存中构造出undo块、已修改的表块，以及已修改的索引块。

     b. 根据undo块进行数据回滚，回滚到插入前的数据状态。


delete

DELETE会生成undo，块将被修改，并把redo发送到重做日志缓冲区---跟update差别不大
commit;
commit并不是把所有的修改持久化到了数据文件，而是所有的redo文件持久化到磁盘文件，
只要所有的重做日志文件持久化到磁盘，这些修改就是永久的了

http://liwenshui322.iteye.com/blog/1488949



