移位操作符（shift operator）
移位操作符操作的运算对象也是二进制的“位”，但是它们只可以被用来处理整数类型（基本
类型的一种） 。左移位操作符（<<）能将操作符左边的运算对象向左移动操作符右侧指定的
位数（在低位补 0）。“有符号”右移位操作符（>>）则将操作符左边的运算对象向右移动操
作符右侧指定的位数。“有符号”右移位操作符使用了“符号扩展”：若符号为正，则在高位插
入 0；若符号为负，则在高位插入 1。Java 中增加了一种“无符号”右移位操作符（>>>） ，它
使用了“零扩展”：无论正负，都在高位插入 0。这一操作符是 C 或 C++没有的。

如果对 char、byte 或者 short 类型的数值进行移位处理，那么在移位进行之前，它们会自动
转换为 int，并且得到的结果也是一个 int 类型的值。而右侧操作数，作为真正移位的位数，
只有其二进制表示中的低 5 位才有用。这样可防止我们移位超过 int 型值所具有的位数。 （译
注：因为 2 的 5 次方为 32，而 int 型值只有 32 位）。若对一个 long 类型的数值进行处理，
最后得到的结果也是 long。此时只会用到右侧操作数的低 6 位，以防止移位超过 long 型数
值具有的位数。

移位可与等号（<<=或>>=或>>>=）组合使用。此时，操作符左边的值会移动由右边的值指
定的位数，再将得到的结果赋回左边的变量。但在进行“无符号”右移结合赋值操作时，可能
会遇到一个问题：   如果对 byte 或 short 值进行这样的移位运算，得到的可能不是正确的结果。
它们会先被转换成 int 类型，再进行右移操作。然后被截断，赋值给原来的类型，在这种情
况下可能得到-1 的结果。下面这个例子演示了这种情况：

