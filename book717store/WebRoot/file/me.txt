开发javaWEB的三层架构:
    * 创建web工程
    * 引入需要的相关的jar包
        * c3p0连接池
          * c3p0-0.9.2-pre1.jar
          * mchange-commons-0.2.jar 
        
        * mysql的jdbc驱动 
          * mysql-connector-java-5.1.10-bin.jar
        
        * dbUtil包
          * commons-dbutils-1.3.jar
          
        * 文件上传和下载
          * commons-fileupload-1.2.1.jar
          * commons-io-1.4.jar
        
        * 处理日志
          * log4j-1.2.11.jar
          * commons-logging-1.1.1.jar
          
        * jsp的标准标签库
          * jstl-1.2.jar
          
        * 软件测试
          * junit-4.8.2.jar  
          
         * 对java.lang的增强工具类
          * commons-lang-2.5.jar
      
     * 连接数据库,使用从c3p0
        * 在当前工厂的src下创建c3p0-config.xml文件,存放c3p0的配置
        
        *  创建JdbcUtils工具类,连接数据库(放置在cn.itcast.util包下)
             
     * 定义jsp页面/manager/category/add.jsp
     
     * 创建表 --图书类别表
		CREATE TABLE category
		(
		   id VARCHAR(40) PRIMARY KEY,
		   NAME VARCHAR(40) NOT NULL UNIQUE,  #分类名称
		   description VARCHAR(255)           #分类描述
		);
		
	 * 创建和表对应的javaBean对象(po对象,持久对象),放置在cn.itcast.domain包下
		   public class Category {
		     private String id;
		     private String name;
		     private String description;
		   }
	  	   
	 * 创建CategoryServlet,放置在cn.itcast.web.manager包下
		    public void save(HttpServletRequest request, HttpServletResponse response)
				throws ServletException, IOException {
				//获取表单的数据
				String name=request.getParameter("name");
				String description=request.getParameter("description");
				//封装表单的数据到Category
				Category category=new Category();
				category.setId(UUID.randomUUID().toString());
				category.setName(name);
				category.setDescription(description);
				
				**************************************************************************************
				实例化业务层CategoryService
				CategoryService categoryService=new CategoryService();
				//调用页业务的方法
				categoryService.saveCategory(category);
				**************************************************************************************
				request.setAttribute("message", Global.CONTROLLER_CATEGORY_ADD_EXCEPTION);
				path="/message.jsp";
			    request.getRequestDispatcher(path).forward(request, response);
		    }
		    
	  * 创建业务层CategoryService,放置在cn.itcast.service包下
	  	    public class CategoryService {
				**************************************************************************
				private CategoryDao categoryDao=DaoFactory.getCategoryDao();
				**************************************************************************

				public void saveCategory(Category category) {
					Connection conn=null;
					try {
						//获取连接
						conn=JdbcUtils.getConnection();
			             //设置连接为非自动提交
						JdbcUtils.beginTransaction(conn);
			    **************************************************************************
			            //调用dao层的方法保存	
						categoryDao.saveCategory(conn,category);
			    **************************************************************************      
			            //提交
						JdbcUtils.commitTransaction(conn);
					} catch (Exception e) {
						//如果出现异常 回滚	
						JdbcUtils.rollbackTransaction(conn);
						e.printStackTrace();
						throw new ServiceException(e.getMessage(),e);
					}finally{
						//关闭资源
						JdbcUtils.closeResource(conn, null, null);
					}
				}
			}
		
	    * 创建BaseDao,放置在cn.itcast.dao包下
		      public abstract class BaseDao {
					public void  update(Connection conn,String sql,Object[] params,String errorMsg){
						try {
							//调用方法保存
							QueryRunner query=new QueryRunner();
							query.update(conn, sql, params);
						} catch (SQLException e) {
							e.printStackTrace();
							throw new DaoException(errorMsg,e);
						}
					}
				}
		
		* 创建dao接口,放置在cn.itcast.dao包下
		  public interface CategoryDao {
	         void saveCategory(Connection conn, Category category);
          }
          
         
        * 创建dao接口的实现类(放置在cn.itcast.dao.impl包下)
	  	     public class CategoryDaoImpl  extends BaseDao implements CategoryDao {
				public void saveCategory(Connection conn, Category category) {
					//设置错误提示信息
					String errorMsg=Global.DAO_CATEGORY_ADD_EXCEPTION;
					//组织sql语句
					String sql="INSERT INTO category(id,name,description) VALUES(?,?,?)";
					//设置sql语句需要的参数
				    Object[] params={category.getId(), category.getName(), category.getDescription()};
				    //调用父类的方法
				    super.update(conn, sql, params, errorMsg);
				}
              }
              
        * 定义简单工厂,获取dao接口的对象(放置在cn.itcast.factory包下),在业务获取工厂
				public class DaoFactory {
					public static  CategoryDao getCategoryDao(){
						 return new CategoryDaoImpl();
					}
				}
				
	     * 测试			
              
	 * dbUtil包
          * commons-dbutils-1.3.jar介绍：
	 			 DbUtils is a very small library of classes,so it won't take long to go throught 
	  he javadocs for each class.
	  	The core classes/interfaces in DbUtils are QueryRunner and ResultSetHandler.
	  	不需要关心其他DbUtils的类如何使用，只要了解核心接口就行：QueryRunner和ResultSetHandler
	  	构造：
	  	QueryRunner()
	  	QueryRunner(javas.sql.DataSource ds)
	  	使用有参的QueryRunner(DataSource ds)的好处是我们无需管Connection对象的创建与关闭了，
	  	后面调用QueryRunner对象的方法也无需传入Connection对象 了。
	  	
	  	QueryRunner queryRunner = new QueryRunner(JdbcUtils.getConnection());
		
		//QueryRunner主要方法
		//更新一列
		queryRunner.update("update Users set username=?,password=? where id=?",new String[]{"11","21","1"});
		
		//删除一列
		queryRunner.update("delete from Users where id＝?", 1);
		
		//如果使用QueryRunner的查询方法也就是query()方法的话那么就需要有对象来接收查询出来 的ResultSet
		//用什么来接收呢？要用到实现ResultSetHandler接口的类
		
		//1）BeanHandler   返回个entitybean对象
		//指定返回哪个entitybean
		ResultSetHandler rsh = new BeanHandler(Category.class);
	  	
		       
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
     
               